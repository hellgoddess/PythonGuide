# Python连载系列：面向对象基础

## 面向对象基础

- 类和对象 - 什么是类 / 什么是对象 / 面向对象其他相关概念
- 定义类 - 基本结构 / 属性和方法 / 构造器 / 析构器 / __str__方法
- 创建对象 
- 面向对象的三大特征  封装 / 继承 / 多态

**这是很多编程语言的一个基础知识，那什么才是面向对象呢？**

要理解面向对象，我们先来看看与面向对象相对应的另外一种程序设计方法：面向过程。

面向过程的编程的基本构成便是“过程”，过程实现的方式就是“函数”，我们通过不同函数来实现不同的功能，并按照程序的执行顺序调用相应的函数，组成一个完整的可以运行的应用程序。我们可以通过把不同的功能在不同的函数中实现或者给函数传递不同的参数来实现不同的功能，这是面向过程中模块化设计的原理。

但是面向过程有很多问题，当我们总是按照教科书上的小例子来学习程序设计时是永远也体会不到面向过程中存在的这些问题的，反而会觉得面向过程更简单，更容易理解。而事实是当我们设计一些大型的应用的时候你将会发现使用面向过程编程是多么的痛苦和无奈，代码极难维护，我们不得不为相似功能设计不同的函数，天长日久，代码量越来越大，函数越来越多，而重复的代码越来越多，噩梦就此产生。

于是乎产生了另外一种设计思想：面向对象，从此程序员发现编程是多么快乐的一件事情。我们可以把现实世界的很多哲学思想或者模型应用于编程，这是计算机的一次伟大的革命。那么究竟何为面向对象？要理解这两个重要的字“对象“，我们首先需要理解一下类和实例：

举一个简单的例子，大家都会下五子棋，我们就以开发一个五子棋的游戏来讲解面向过程和面向对象最本质的区别，在早期以面向过程为主要开发方法时，我们是这样来设计这个游戏的：

1. 开始游戏；
2. 黑方出子；
3. 绘制画面；
4. 判断胜负；
5. 白方出子；
6. 绘制画面；
7. 判断胜负；
8. 循环2、3、4、5、6、7步；
9. 输出结果。

最后将每一个步骤作为一个处理函数开发出来，每次运行都调用一遍函数（或者过程）。面向过程最关键的概念就是“过程”，所以程序运行都是一步接一步，从上往下。

而面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为：

1. 黑白双方：负责出子和悔棋；
2. 棋盘系统：负责绘制画面；
3. 规则系统：负责判定诸如犯规、输赢等；
4. 输入输出系统：负责接收黑白子放的位置信息和输出游戏过程中的相关信息。

这就是面向对象，更强调将程序模块化，我们甚至可以将该程序抽象出来使其适用于五子棋和围棋（它们除了规则不一样以外没有其它区别，那么我们只需要修改规则系统便可轻易支持围棋）。

**再初步理解了什么是面向对象的时候，我们接下来就要去理解一下什么是类，什么是对象**

---

**类** 和 **对象** 是 **面向对象编程的 两个 核心概念**

### 类

+ **类** 是对一群具有 **相同 特征** 或者 **行为** 的事物的一个统称，是抽象的，**不能直接使用**
  + **特征** 被称为 **属性**
  + **行为** 被称为 **方法**
+ **类** 就相当于制造飞机时的**图纸**，是一个 **模板**，是 **负责创建对象的**

![image-20210401142113965](https://gitee.com/chushi123/picgo/raw/master/picture/image-20210401142113965.png)

### 对象

+ **对象** 是 **由类创建出来的一个具体存在**，可以直接使用
+ 由 **哪一个类** 创建出来的 **对象**，就拥有在 **哪一个类** 中定义的：
  + 属性
  + 方法
+ **对象** 就相当于用 **图纸** **制造** 的飞机

**在程序开发中，应该先有类，再有对象**

## 类和对象的关系

+ **类是模板**，**对象** 是根据 **类** 这个模板创建出来的，应该 **先有类，再有对象**
+ **类** 只有一个，而 **对象** 可以有很多个
  + **不同的对象** 之间 **属性** 可能会各不相同
+ **类** 中定义了什么 **属性和方法**，**对象** 中就有什么属性和方法，**不可能多，也不可能少**

### 定义类

在Python中可以使用`class`关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来，代码如下所示。

```Python
class Student(object):

    # __init__是一个特殊方法用于在创建对象时进行初始化操作
    # 通过这个方法我们可以为学生对象绑定name和age两个属性
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def study(self, course_name):
        print('%s正在学习%s.' % (self.name, course_name))

    
    # 驼峰命名法(驼峰标识)
    def watch_movie(self):
        if self.age < 18:
            print('%s正在看蜡笔小新.' % self.name)
        else:
            print('%s正在观看海贼王' % self.name)
```

### 创建和使用对象

当我们定义好一个类之后，可以通过下面的方式来创建对象并给对象发消息。

```
def main():
    # 创建学生对象并指定姓名和年龄
    stu1 = Student('海森堡', 19)
    # 给对象发study消息
    stu1.study('大话Python')
    # 给对象发watch_av消息
    stu1.watch_movie()
   


if __name__ == '__main__':
    main()
```

## 类的设计

在使用面相对象开发前，应该首先分析需求，确定一下，程序中需要包含哪些类！

![image-20210401143347135](https://gitee.com/chushi123/picgo/raw/master/picture/image-20210401143347135.png)

在程序开发中，要设计一个类，通常需要满足一下三个要素：

1. **类名** 这类事物的名字，**满足大驼峰命名法**
2. **属性** 这类事物具有什么样的特征
3. **方法** 这类事物具有什么样的行为

### 大驼峰命名法

```
CapWords
```

1. 每一个单词的首字母大写
2. 单词与单词之间没有下划线

### 面向对象的三大特征

面向想有三大特征： 封装，继承，多态，下面我们来了解一下这三大特性。

**什么是封装呢？**

我个人的理解就是，把你的属性隐藏起来，外界不可获取到。我简单的分为四点去理解：

1. **封装** 是面向对象编程的一大特点
2. 面向对象编程的 **第一步** —— 将 **属性** 和 **方法** **封装** 到一个抽象的 **类** 中
3. **外界** 使用 **类** 创建 **对象**，然后 **让对象调用方法**
4. **对象方法的细节** 都被 **封装** 在 **类的内部**

我们通过一个例子来了解一下什么是封装：

**需求**

1. **小明** **体重** `75.0` 公斤
2. 小明每次 **跑步** 会减肥 `0.5` 公斤
3. 小明每次 **吃东西** 体重增加 `1` 公斤

![image-20210401144210055](https://gitee.com/chushi123/picgo/raw/master/picture/image-20210401144210055.png)

> 提示：在 **对象的方法内部**，是可以 **直接访问对象的属性** 的！

+ 代码实现

```
class Person:
    """人类"""
“”“封装”“”
    def __init__(self, name, weight):

        self.name = name
        self.weight = weight

"""内置的方法，下一节会讲到"""
    def __str__(self):

        return "我的名字叫 %s 体重 %.2f 公斤" % (self.name, self.weight)

    def run(self):
        """跑步"""

        print("%s 爱跑步，跑步锻炼身体" % self.name)
        self.weight -= 0.5

    def eat(self):
        """吃东西"""

        print("%s 是吃货，吃完这顿再减肥" % self.name)
        self.weight += 1


xiaoming = Person("小明", 75)

xiaoming.run()
xiaoming.eat()
xiaoming.eat()

print(xiaoming)
```

#### 定义一个类描述数字时钟。

```Python
from time import sleep


class Clock(object):
    """数字时钟"""

    def __init__(self, hour=0, minute=0, second=0):
        """初始化方法

        :param hour: 时
        :param minute: 分
        :param second: 秒
        """
        self._hour = hour
        self._minute = minute
        self._second = second

    def run(self):
        """走字"""
        self._second += 1
        if self._second == 60:
            self._second = 0
            self._minute += 1
            if self._minute == 60:
                self._minute = 0
                self._hour += 1
                if self._hour == 24:
                    self._hour = 0

    def show(self):
        """显示时间"""
        return '%02d:%02d:%02d' % \
               (self._hour, self._minute, self._second)


def main():
    clock = Clock(23, 59, 58)
    while True:
        print(clock.show())
        sleep(1)
        clock.run()


if __name__ == '__main__':
    main()
```

### 继承

继承，从字面意识上理解，就是可以实现从父亲辈继承到一些遗产什么的，而在Python中就是可以继承到一些属性和方法。Python与Java在继承中有一个非常大的区别就是Python支持多继承，而java只支持单继承。

## 单继承

### 继承的概念、语法和特点

**继承的概念**：**子类** 拥有 **父类** 的所有 **方法** 和 **属性**

![image-20210401144847194](https://gitee.com/chushi123/picgo/raw/master/picture/image-20210401144847194.png)

#### 1) 继承的语法

```
class 类名(父类名):

    pass
```

+ `Dog` 类是 `Animal` 类的**子类**，`Animal` 类是 `Dog` 类的**父类**，`Dog` 类从 `Animal` 类**继承**
+ `Dog` 类是 `Animal` 类的**派生类**，`Animal` 类是 `Dog` 类的**基类**，`Dog` 类从 `Animal` 类**派生**

#### 2) 专业术语

+ `C` 类从 `B` 类继承，`B` 类又从 `A` 类继承
+ 那么 `C` 类就具有 `B` 类和 `A` 类的所有属性和方法

### 方法的重写

+ **子类** 拥有 **父类** 的所有 **方法** 和 **属性**
+ **子类** 继承自 **父类**，可以直接 **享受** 父类中已经封装好的方法，不需要再次开发

**应用场景**

+ 当 **父类** 的方法实现不能满足子类需求时，可以对方法进行 **重写(override)**

![image-20210401145055969](https://gitee.com/chushi123/picgo/raw/master/picture/image-20210401145055969.png)

**重写** 父类方法有两种情况：

1. **覆盖** 父类的方法
2. 对父类方法进行 **扩展**

#### 1) 覆盖父类的方法

+ 如果在开发中，**父类的方法实现** 和 **子类的方法实现**，**完全不同**
+ 就可以使用 **覆盖** 的方式，**在子类中** **重新编写** 父类的方法实现

> 具体的实现方式，就相当于在 **子类中** 定义了一个 **和父类同名的方法并且实现**

#### 2) 对父类方法进行 **扩展**

+ 如果在开发中，**子类的方法实现** 中 **包含** **父类的方法实现**
  + **父类原本封装的方法实现** 是 **子类方法的一部分**
+ 就可以使用 **扩展** 的方式
  + **在子类中** **重写** 父类的方法
  + 在需要的位置使用 `super().父类方法` 来调用父类方法的执行
  + 代码其他的位置针对子类的需求，编写 **子类特有的代码实现**

##### 关于 `super`

+ 在 `Python` 中 `super` 是一个 **特殊的类**
+ `super()` 就是使用 `super` 类创建出来的对象
+ **最常** 使用的场景就是在 **重写父类方法时**，调用 **在父类中封装的方法实现**

### 父类的 私有属性 和 私有方法

1. **子类对象** **不能** 在自己的方法内部，**直接** 访问 父类的 **私有属性** 或 **私有方法**
2. **子类对象** 可以通过 **父类** 的 **公有方法** **间接** 访问到 **私有属性** 或 **私有方法**

> - **私有属性、方法** 是对象的隐私，不对外公开，**外界** 以及 **子类** 都不能直接访问
> - **私有属性、方法** 通常用于做一些内部的事情

![image-20210401145333011](https://gitee.com/chushi123/picgo/raw/master/picture/image-20210401145333011.png)

- `B` 的对象不能直接访问 `__num2` 属性
- `B` 的对象不能在 `demo` 方法内访问 `__num2` 属性
- `B` 的对象可以在 `demo` 方法内，调用父类的 `test` 方法
- 父类的 `test` 方法内部，能够访问 `__num2` 属性和 `__test` 方法

## 多继承

**概念**

+ **子类** 可以拥有 **多个父类**，并且具有 **所有父类** 的 **属性** 和 **方法**
+ 例如：**孩子** 会继承自己 **父亲** 和 **母亲** 的 **特性**



![image-20210401150811858](https://gitee.com/chushi123/picgo/raw/master/picture/image-20210401150811858.png)

**语法**

```
class 子类名(父类名1, 父类名2...)
    pass
```

#### Python 中的 MRO —— 方法搜索顺序(了解)

- `Python` 中针对 **类** 提供了一个 **内置属性** `__mro__` 可以查看 **方法** 搜索顺序
- MRO 是 `method resolution order`，主要用于 **在多继承时判断 方法、属性 的调用 路径**

```
print(C.__mro__)
```

**输出结果**

```
(<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)
```

- 在搜索方法时，是按照 `__mro__` 的输出结果 **从左至右** 的顺序查找的
- 如果在当前类中 **找到方法，就直接执行，不再搜索**
- 如果 **没有找到，就查找下一个类** 中是否有对应的方法，**如果找到，就直接执行，不再搜索**
- 如果找到最后一个类，还没有找到方法，程序报错

## 多态

重温一下面向对象三大特性：

1. **封装** 根据 **职责** 将 **属性** 和 **方法** **封装** 到一个抽象的 **类** 中
   - 定义类的准则
2. **继承** **实现代码的重用**，相同的代码不需要重复的编写
   - 设计类的技巧
   - 子类针对自己特有的需求，编写特定的代码
3. **多态** 不同的 **子类对象** 调用相同的 **父类方法**，产生不同的执行结果
   - **多态** 可以 **增加代码的灵活度**
   - 以 **继承** 和 **重写父类方法** 为前提
   - 是调用方法的技巧，**不会影响到类的内部设计**

![image-20210401150953469](https://gitee.com/chushi123/picgo/raw/master/picture/image-20210401150953469.png)

## 多态案例演练

1.在 `Dog` 类中封装方法 `game`

- 普通狗只是简单的玩耍

2.定义 `XiaoTianDog` 继承自 `Dog`，并且重写 `game` 方法

- 哮天犬需要在天上玩耍

3.定义 `Person` 类，并且封装一个 **和狗玩** 的方法

+ 在方法内部，直接让 **狗对象** 调用 `game` 方法

![image-20210401151131412](https://gitee.com/chushi123/picgo/raw/master/picture/image-20210401151131412.png)

**案例小结**

- `Person` 类中只需要让 **狗对象** 调用 `game` 方法，而不关心具体是 **什么狗**
  - `game` 方法是在 `Dog` 父类中定义的
- 在程序执行时，传入不同的 **狗对象** 实参，就会产生不同的执行效果

> **多态** 更容易编写出出通用的代码，做出通用的编程，以适应需求的不断变化！

```
class Dog(object):

    def __init__(self, name):
        self.name = name

    def game(self):
        print("%s 蹦蹦跳跳的玩耍..." % self.name)


class XiaoTianDog(Dog):

    def game(self):
        print("%s 飞到天上去玩耍..." % self.name)


class Person(object):

    def __init__(self, name):
        self.name = name

    def game_with_dog(self, dog):

        print("%s 和 %s 快乐的玩耍..." % (self.name, dog.name))

        # 让狗玩耍
        dog.game()


# 1. 创建一个狗对象
# wangcai = Dog("旺财")
wangcai = XiaoTianDog("飞天旺财")

# 2. 创建一个小明对象
xiaoming = Person("小明")

# 3. 让小明调用和狗玩的方法
xiaoming.game_with_dog(wangcai)
```

![名片](https://gitee.com/chushi123/picgo/raw/master/picture/名片.png)
